#include "includes.h"

/// <summary>
/// Функция для демонстрации работы программы с дисциплиной LIFO
/// </summary>
void LIFOOperations() {
    int value; // переменная для хранения ввода пользователя
    LIFOElem* tail = MakeLIFO(); // создаю список с дисциплиной LIFO, записываю его "хвост" в переменную tail
 
    cout << endl << "Вывод списка с начала:" << endl;
    LIFOPrintFromFirst(tail);

    cout << endl << "Вывод списка с конца:" << endl;
    LIFOPrintFromLast(tail);

    cout << "\nВведите значение - целое число - для поиска (0 - конец): > "; 
    cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0

    while (value != 0) // пока не введут 0, выдаю результаты поиска значений в списке
    {
        int count = LIFOCount(tail, value);

        cout << endl << "Количество элементов " << value << " = " << count << endl;

        cout << "Введите значение - целое число - для поиска (0 - конец): > ";
        cin >> value;
    }

    cout << "\nВведите значение - целое число - для удаления (0 - конец): > ";
    cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0

    while (value != 0) // пока не введут 0, удаляю элементы из списка и вывожу его, чтобы изменения были наглядны
    {
        LIFORemove(tail, value);

        cout << endl << "Вывод списка с начала:" << endl;
        LIFOPrintFromFirst(tail);

        cout << endl << "Вывод списка с конца:" << endl;
        LIFOPrintFromLast(tail);

        cout << "Введите значение - целое число - для удаления (0 - конец): > ";
        cin >> value;
    }
}

/// <summary>
/// Функция для демонстрации работы программы с дисциплиной FIFO
/// </summary>
void FIFOOperations() {
    int value; // переменная для хранения ввода пользователя
    FIFOElem* head = MakeFIFO(); // создаю список с дисциплиной FIFO, записываю его "голову" в переменную head

    cout << endl << "Вывод списка с начала:" << endl;
    FIFOPrintFromFirst(head);

    cout << endl << "Вывод списка с конца:" << endl;
    FIFOPrintFromLast(head);

    cout << "\nВведите значение - целое число - для поиска (0 - конец): > ";
    cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0

    while (value != 0) // пока не введут 0, выдаю результаты поиска значений в списке
    {
        int count = FIFOCount(head, value);

        cout << endl << "Количество элементов " << value << " = " << count << endl;

        cout << "Введите значение - целое число - для поиска (0 - конец): > ";
        cin >> value;
    }

    cout << "\nВведите значение - целое число - для удаления (0 - конец): > ";
    cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0

    while (value != 0) // пока не введут 0, удаляю элементы из списка и вывожу его, чтобы изменения были наглядны
    {
        FIFORemove(head, value);

        cout << endl << "Вывод списка с начала:" << endl;
        FIFOPrintFromFirst(head);

        cout << endl << "Вывод списка с конца:" << endl;
        FIFOPrintFromLast(head);

        cout << "Введите значение - целое число - для удаления (0 - конец): > ";
        cin >> value;
    }
}

/// <summary>
/// Функция для демонстрации работы программы с дисциплиной односвязный отсортированный список
/// </summary>
void OWSLOperations() {
    int value; // переменная для хранения ввода пользователя
    OWSLElem* head = MakeOWSL(); // создаю список с дисциплиной "односвязный отсортированный список", записываю его "голову" в переменную head

    cout << endl << "Вывод списка с начала:" << endl;
    OWSLPrintFromFirst(head);

    cout << endl << "Вывод списка с конца:" << endl;
    OWSLPrintFromLast(head);

    cout << "\nВведите значение - целое число - для поиска (0 - конец): > ";
    cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0

    while (value != 0) // пока не введут 0, выдаю результаты поиска значений в списке
    {
        int count = OWSLCount(head, value);

        cout << endl << "Количество элементов " << value << " = " << count << endl;

        cout << "Введите значение - целое число - для поиска (0 - конец): > ";
        cin >> value;
    }

    cout << "\nВведите значение - целое число - для удаления (0 - конец): > ";
    cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0

    while (value != 0) // пока не введут 0, удаляю элементы из списка и вывожу его, чтобы изменения были наглядны
    {
        OWSLRemove(head, value);

        cout << endl << "Вывод списка с начала:" << endl;
        OWSLPrintFromFirst(head);

        cout << endl << "Вывод списка с конца:" << endl;
        OWSLPrintFromLast(head);

        cout << "Введите значение - целое число - для удаления (0 - конец): > ";
        cin >> value;
    }
}

/// <summary>
/// Функция для демонстрации работы программы с дисциплиной двусвязный отсортированный список
/// </summary>
void TWSLOperations() {
    int value; // переменная для хранения ввода пользователя
    tuple<TWSLElem*, TWSLElem*> ends = MakeTWSL(); // создаю список с дисциплиной "двусвязный отсортированный список"
    TWSLElem* head = get<0>(ends); // для двусвязных списков логично иметь в быстром доступе как "голову", так и "хвост"
    TWSLElem* tail = get<1>(ends); // поэтому, из метода возвращаю кортеж с двумя указателями - на первый элемент списка и на последний

    cout << endl << "Вывод списка с начала:" << endl;
    TWSLPrintFromFirst(head);

    cout << endl << "Вывод списка с конца:" << endl;
    TWSLPrintFromLast(tail);

    cout << "\nВведите значение - целое число - для поиска (0 - конец): > ";
    cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0

    while (value != 0) // пока не введут 0, выдаю результаты поиска значений в списке
    {
        int count = TWSLCount(head, value);

        cout << endl << "Количество элементов " << value << " = " << count << endl;

        cout << "Введите значение - целое число - для поиска (0 - конец): > ";
        cin >> value;
    }

    cout << "\nВведите значение - целое число - для удаления (0 - конец): > ";
    cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0

    while (value != 0) // пока не введут 0, удаляю элементы из списка и вывожу его, чтобы изменения были наглядны
    {
        TWSLRemove(head, tail, value);

        cout << endl << "Вывод списка с начала:" << endl;
        TWSLPrintFromFirst(head);

        cout << endl << "Вывод списка с конца:" << endl;
        TWSLPrintFromLast(tail);

        cout << "Введите значение - целое число - для удаления (0 - конец): > ";
        cin >> value;
    }
}

/// <summary>
/// Функция для демонстрации работы программы с дисциплиной однонаправленный список с сортировкой элементов по двум ключам

/// </summary>
void SLTFOperations() {
    string name; // переменная для хранения ввода пользователя
    int ratingPlace; // переменная для хранения ввода пользователя
    tuple<SLTFElem*, SLTFElem*> heads = MakeSLTF(); // создаю список с дисциплиной "однонаправленный список с сортировкой элементов по двум ключам"
    SLTFElem* headByName = get<0>(heads); // так как одновременно в списке есть два указателя на следующие элементы, в зависимости от значений двух полей соответственно
    SLTFElem* headByRating = get<1>(heads); // то из метода возвращаю и запоминаю "головы" для каждой из сортировок
    // ВАЖНО! список здесь - один, используются одни и те же данные, но за счёт двух указателей на следующий элемент, появляется
    // возможность, не тратя память на еще один список точно таких же элементов, хранить сразу две сортировки по значениям

    cout << endl << "Вывод списка с начала:" << endl;
    SLTFPrintFromFirst(headByName, headByRating);

    cout << endl << "Вывод списка с конца:" << endl;
    SLTFPrintFromLast(headByName, headByRating);

    cout << "\n\nВведите имя студента для поиска (0 - конец ввода): > ";
    cin >> name; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0

    while (name != "0") // пока не введут 0, выдаю результаты поиска значений в списке
    { // если имя было введено, то пользователь обязан ввести рейтинг данного студента. Возможности закончить ввод на рейтинге не предоставляется
        cout << "Введите место студента в рейтинге для поиска: > ";
        cin >> ratingPlace;

        int count = SLTFCount(headByName, name, ratingPlace);

        cout << endl << "Количество элементов " << "(" << headByName->name << " " << headByName->ratingPlace << ")" << " = " << count << endl;

        cout << "\n\nВведите имя студента для поиска (0 - конец ввода): > ";
        cin >> name;
    }

    cout << "Введите имя студента для удаления (0 - конец ввода): > ";
    cin >> name; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0

    while (name != "0") // пока не введут 0, удаляю элементы из списка и вывожу его, чтобы изменения были наглядны
    { // Возможности закончить ввод на рейтинге не предоставляется
        cout << "Введите место студента в рейтинге для удаления: > ";
        cin >> ratingPlace;

        SLTFRemove(headByName, headByRating, name, ratingPlace);

        cout << endl << "Вывод списка с начала:" << endl;
        SLTFPrintFromFirst(headByName, headByRating);

        cout << endl << "Вывод списка с конца:" << endl;
        SLTFPrintFromLast(headByName, headByRating);

        cout << "Введите имя студента для удаления (0 - конец ввода): > ";
        cin >> name;
    }
}

void AVLTreeOperations() {
    int value; // переменная для хранения ввода пользователя
    AVLTreeNode* root = MakeAVLTree(); // создаю идеально сбалансированное бинарное дерево и присваиваю переменной root его корень

    cout << "\nВывод элементов дерева в порядке возрастания: ";
    if (!root)
        cout << "Дерево пусто!" << endl;
    else
        PrintTreeByAscending(root);

    cout << "\nВывод элементов дерева в порядке убывания: ";
    if (!root)
        cout << "Дерево пусто!" << endl;
    else
        PrintTreeByDescending(root);

    cout << "\nВведите значение - целое число - для поиска (0 - конец): > ";
    cin >> value;

    while (value != 0) // пока не введут 0, выдаю результаты поиска значений в списке
    {
        int count = FindValue(root, value);

        cout << endl << "Количество элементов " << value << " = " << count << endl;

        cout << "Введите значение - целое число - для поиска (0 - конец): > ";
        cin >> value;
    }

    cout << "\nВведите значение - целое число - для удаления (0 - конец): > ";
    cin >> value;

    while (value != 0) // пока не введут 0, удаляю элементы из дерева и вывожу его, чтобы изменения были наглядны
    {
        root = RemoveValue(root, value);

        cout << "\nВывод элементов дерева в порядке возрастания: ";
        if (!root)
            cout << "Дерево пусто!" << endl;
        else
            PrintTreeByAscending(root);

        cout << "\nВывод элементов дерева в порядке убывания: ";
        if (!root)
            cout << "Дерево пусто!" << endl;
        else
            PrintTreeByDescending(root);

        cout << "\nВведите значение - целое число - для удаления (0 - конец): > ";
        cin >> value;
    }

    DeleteTree(root); // в конце работы программы удаляю дерево из памяти
}

int main() {
    // просто вызываю демонстрации работ каждой созданной мною дисциплины (всего - 6)

    system("chcp 1251 >> null"); // строчка для того, чтобы работал вывод русского языка из переменных string в консоль

    cout << "Дисциплина LIFO\n" << endl;
    LIFOOperations();

    system("cls"); // очистка консоли после того, как дисциплина отработана

    cout << "Дисциплина FIFO\n" << endl;
    FIFOOperations();

    system("cls"); // очистка консоли после того, как дисциплина отработана

    cout << "Однонаправленный список с сортировкой элементов по ключу (дисциплина FIFO)\n" << endl;
    OWSLOperations();

    system("cls"); // очистка консоли после того, как дисциплина отработана

    cout << "Двунаправленный список с сортировкой элементов по ключу (дисциплина FIFO)\n" << endl;
    TWSLOperations();

    system("cls"); // очистка консоли после того, как дисциплина отработана

    cout << "Однонаправленный список с сортировкой элементов по двум ключам (дисциплина FIFO)\n" << endl;
    SLTFOperations();

    system("cls"); // очистка консоли после того, как дисциплина отработана

    cout << "Идеально-сбалансированное бинарное дерево\n" << endl;
    AVLTreeOperations();
}