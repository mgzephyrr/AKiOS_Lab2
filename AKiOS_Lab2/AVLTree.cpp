#include "includes.h"

// В ДАННОМ ФАЙЛЕ НАХОДЯТСЯ ВСЕ ФУНКЦИИ, ОТВЕЧАЮЩИЕ ЗА БИЗНЕС-ЛОГИКУ БИНАРНОГО СБАЛАНСИРОВАННОГО ДЕРЕВА

/// <summary>
/// Функция для полного создания бинарного сбалансированного дерева
/// </summary>
/// <returns> указатель на "корень" дерева </returns>
AVLTreeNode* MakeAVLTree() {
    int value;
    AVLTreeNode* root = nullptr;

    cout << "Введите значение - целое число (0 - конец ввода): > ";
    cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0 и оставить в этом случае список пустым

    while (value != 0) { // если ввели не ноль
        root = AddValue(root, value);

        cout << "Введите значение - целое число (0 - конец ввода): > ";
        cin >> value;
    }

    return root;
}

/// <summary>
/// Функция для получения "высоты" конкретного узла дерева (высота - наибольшее расстояние от листа дерева до заданного узла)
/// </summary>
/// <param name="node"> какого узла нужна высота </param>
/// <returns> высоту узла </returns>
int GetHeight(AVLTreeNode* node) {
    if (node) //если запрос от существующего на самом деле узла
        return node->height; //возвращаю его высоту

    else //если запрос от nullptr
        return 0;
}

/// <summary>
/// Функция, для получения "баланса" конкретного узла дерева (баланс - разность высот правого и левого "ребёнка" узла)
/// </summary>
/// <param name="node"> какого узла нужен баланс </param>
/// <returns> баланс узла </returns>
int GetBalance(AVLTreeNode* node) {
    return GetHeight(node->right) - GetHeight(node->left);
}

/// <summary>
/// Функция для перерасчёта значения высоты у узла (после вставки или удаления)
/// </summary>
/// <param name="node"> узел, которому нужно пересчитать высоту </param>
void FixHeight(AVLTreeNode* node) {
    node->height = max(GetHeight(node->left), GetHeight(node->right)) + 1;
}

/// <summary>
/// Функция, реализующая малый левый поворот. Применяется для балансировки дерева
/// </summary>
/// <param name="node"> относительно какого узла произведем малый левый поворот </param>
/// <returns> вставший на место повёрнутого только что узла узел </returns>
AVLTreeNode* SmallLeftTurn(AVLTreeNode* node) {
    if (node) { // если функция вызывается от реально существующего узла
        AVLTreeNode* temp = node->right; // дополнительный указатель на правого ребенка поворачиваемого узла
        node->right = temp->left; // "перехватываем" левого "внука" правого "ребёнка" и передаем его вместо правого "ребенка" поворачиваемому узлу
        temp->left = node; // левый "ребенок" вставшего на место поворачиваемого узла элемента теперь его бывший "родитель"

        // Можно доказать, что только у этих двух узлов поменяется высота, больше ни для каких элементов FixHeight вызывать не нужно 
        FixHeight(node); // исправляем значение высоты у элемента, который теперь ниже из них двоих (ВАЖНО! так как, если сначала исправить значение того, что выше, то высота может рассчитаться неверно)
        FixHeight(temp); // исправляем значение высоты у элемента, который теперь выше

        return temp;
    }
    else { // если функция вызывалась от несуществующего узла (нулевой указатель)
        return nullptr;
    }
}

/// <summary>
/// Функция, реализующая малый правый поворот. Применяется для балансировки дерева
/// </summary>
/// <param name="node"> относительно какого узла произведем малый правый поворот </param>
/// <returns> вставший на место повёрнутого только что узла узел </returns>
AVLTreeNode* SmallRightTurn(AVLTreeNode* node) {
    if (node) { // если функция вызывается от реально существующего узла
        AVLTreeNode* temp = node->left; // дополнительный указатель на левого ребенка поворачиваемого узла
        node->left = temp->right; // "перехватываем" правого "внука" левого "ребёнка" и передаем его вместо левого "ребенка" поворачиваемому узлу
        temp->right = node; // левый "ребенок" вставшего на место поворачиваемого узла элемента теперь его бывший "родитель"

        // Можно доказать, что только у этих двух узлов поменяется высота, больше ни для каких элементов FixHeight вызывать не нужно 
        FixHeight(node); // исправляем значение высоты у элемента, который теперь ниже из них двоих (ВАЖНО! так как, если сначала исправить значение того, что выше, то высота может рассчитаться неверно)
        FixHeight(temp); // исправляем значение высоты у элемента, который теперь выше

        return temp;
    }
    else { // если функция вызывалась от несуществующего узла (нулевой указатель)
        return nullptr;
    }
}

/// <summary>
/// Функция, реализующая большой левый поворот. Применяется для балансировки дерева
/// </summary>
/// <param name="node"> относительно какого узла произведем большой левый поворот </param>
/// <returns> вставший на место повёрнутого только что узла узел </returns>
AVLTreeNode* BigLeftTurn(AVLTreeNode* node) {
    if (node) { // если функция вызывается от реально существующего узла
        node->right = SmallRightTurn(node->right); // производим малый правый поворот относительно правого ребенка узла
        node = SmallLeftTurn(node); // производим малый левый поворот относительно узла

        return node;
    }
    else { // если функция вызывалась от несуществующего узла (нулевой указатель)
        return nullptr;
    }
}

/// <summary>
/// Функция, реализующая большой правый поворот. Применяется для балансировки дерева
/// </summary>
/// <param name="node"> относительно какого узла произведем большой правый поворот </param>
/// <returns> вставший на место повёрнутого только что узла узел </returns>
AVLTreeNode* BigRightTurn(AVLTreeNode* node) {
    if (node) { // если функция вызывается от реально существующего узла
        node->left = SmallLeftTurn(node->left); // производим малый левый поворот относительно левого ребенка узла
        node = SmallRightTurn(node); // производим малый правый поворот относительно узла

        return node;
    }
    else { // если функция вызывалась от несуществующего узла (нулевой указатель)
        return nullptr;
    }
}

/// <summary>
/// Функция, приводящая дерево из несбалансированного состояния в сбалансированное (После вставки или удаления элементов).
/// </summary>
/// <param name="node"> относительно какого узла производим баланс </param>
/// <returns> сбалансированное поддерево </returns>
AVLTreeNode* ReBalance(AVLTreeNode* node) {
    FixHeight(node); // для верного баланса нужно точно "исправить" значение высоты текущего узла

    if (GetBalance(node) == 2) // если правое поддерево выше левого на 2 пункта
        if (GetBalance(node->right) < 0) // если при этом у правого "ребенка" левое поддерево выше правого
            return BigLeftTurn(node); // то производим большой левый поворот

        else // если же правое поддерево на том же уровне, что и левое или выше
            return SmallLeftTurn(node); // производим малый левый поворот

    if (GetBalance(node) == -2) // если левое поддерево выше правого на 2 пункта
        if (GetBalance(node->left) > 0) // если при этом у левого "ребенка" правое поддерево выше левого
            return BigRightTurn(node); // то производим большой правый поворот

        else // если же левое поддерево на том же уровне, что и правое или выше
            return SmallRightTurn(node); // производим малый правый поворот

    return node;
}

/// <summary>
/// Функция для добавления элемента в дерево
/// </summary>
/// <param name="node"> поддерево, куда добавляем узел </param>
/// <param name="value"> значение добавляемого узла </param>
/// <returns> поддерево с добавленным узлом </returns>
AVLTreeNode* AddValue(AVLTreeNode* node, int value) {

    if (!node) // база рекурсии (как только дошли до конца дерева, добавляем в это место новый "лист")
        return new AVLTreeNode(value); 

    if (value == node->value) { // бинарное дерево, как правило, не включает в себя одинаковые значения
        cout << "Значение уже есть в дереве!" << endl;
        return node;
    }

    if (value > node->value) // если значение больше, чем текущее, то идём вправо по дереву
        node->right = AddValue(node->right, value); 

    else // иначе идём влево по дереву
        node->left = AddValue(node->left, value);

    return ReBalance(node); // все поддеревья, которые были задействованы в процессе добавления узла, после его добавления, придётся перебалансировать
                            // это происходит как раз на выходе из рекурсии
}

/// <summary>
/// Функция для удаления узла из дерева
/// </summary>
/// <param name="node"> поддерево из которого нужно удалить элемент </param>
/// <param name="value"> значение которое нужно удалить </param>
/// <returns> поддерево без удаляемого элемента </returns>
AVLTreeNode* RemoveValue(AVLTreeNode* node, int value) {

    if (!node) // база рекурсии (если дошли до конца дерева и не нашли элемент, то просто выходим из рекурсии)
        return nullptr;

    if (value < node->value) // если удаляемое значение меньше чем значение текущего узла, идём налево
        node->left = RemoveValue(node->left, value); // база рекурсии выглядит так как выглядит в силу того, что здесь мы пишем
                                                     // что ребенок данного узла (указатель) РАВЕН тому, что вернет функция. А в конечном итоге
                                                     // она вернёт просто узел, который когда-то являлся чем-то "ребенком", по обратному выходу из рекурсии,
                                                     // автоматически "встанет" куда надо

    else if (value > node->value) // если удаляемое значение больше чем значение текущего узла, идём направо
        node->right = RemoveValue(node->right, value);

    else { // если пришли в узел, который нужно удалить
        if (!node->right) { // если у узла, который нужно удалить, нет правого поддерева
            AVLTreeNode* temp = node->left; // запоминаем указатель на левое поддерево удаляемого узла
            delete node; // удаляем узел
            return temp; // возвращаем указатель на его левое поддерево в качестве результата удаления
        }
        else { // если правое поддерево всё же есть
            AVLTreeNode* temp = node->right; // создаю два доп. указателя на правое поддерево удаляемого объекта
            AVLTreeNode* secondtemp = node->right; // создаю два доп. указателя на правое поддерево удаляемого объекта

            while (temp->left) { // бегу максимально "влево" по дереву от правого "ребенка" удаляемого узла, чтобы найти узел, с которым
                                 // можно будет обменяться значениями, чтобы привести ситуацию к более простому случаю.
                temp = temp->left;
            }

            while (secondtemp->left != nullptr && secondtemp->left != temp) { // вторым указателем добегаю до "родителя" того элемента, который
                                                                              // является узлом, с которым я обменяюсь значениями
                secondtemp = secondtemp->left;
            }

            if (secondtemp == temp) // если произошла ситуация, что у правого "ребенка" изначально было некуда "бежать" (не было левого поддерева)
                node->right = temp->right; // то, родителю удаляемого узла передаю вместо него его правого "ребенка"

            else { // если левое поддерево всё-таки было
                secondtemp->left = temp->right; // родителю узла, с которым произошёл "обмен значениями", в левое поддерево отдаю
                                                // правого "внука" его левого "ребенка"
            }

            int tempValue = temp->value; // обмениваю значения между узлом который я должен был удалить и узлом, который удаляю на самом деле
            temp->value = node->value; // обмениваю значения между узлом который я должен был удалить и узлом, который удаляю на самом деле
            node->value = tempValue; // обмениваю значения между узлом который я должен был удалить и узлом, который удаляю на самом деле

            delete temp; // удаляю узел с нужным мне значением
        }           
    }
    return ReBalance(node); // все поддеревья, которые были задействованы в процессе удаления узла необходимо перебалансировать
}

/// <summary>
/// Функция для вывода всех значений дерева по возрастанию
/// </summary>
/// <param name="node"> поддерево, из которого нужно вывести все значения в порядке возрастания </param>
void PrintTreeByAscending(AVLTreeNode* node) {
    if (!node) // база рекурсии (если пришли в "ребенка" листа, то выходим из рекурсии)
        return;

    PrintTreeByAscending(node->left); // сначала вызываем рекурсию от левого поддерева (т.к. левый ребенок всегда меньше родителя и его правого ребенка)
    cout << node->value << " "; // затем вывожу значение самого узла, т.к. его значение всегда меньше всех значений его правого поддерева
    PrintTreeByAscending(node->right); // наконец, иду в правое поддерево, где происходит точно такой же порядок действий
}

/// <summary>
/// Функция для вывода всех значений дерева по убыванию
/// </summary>
/// <param name="node"> поддерево, из которого нужно вывести все значения в порядке убывания </param>
void PrintTreeByDescending(AVLTreeNode* node) {
    if (!node) // база рекурсии (если пришли в "ребенка" листа, то выходим из рекурсии)
        return;

    PrintTreeByDescending(node->right); // сначала вызываем рекурсию от правого поддерева (т.к. правый ребенок всегда больше своего родителя и его левого ребенка)
    cout << node->value << " "; // затем вывожу значение самого узла, т.к. его значение всегда больше всех значений его левого поддерева
    PrintTreeByDescending(node->left); // наконец, иду в левое поддерево, где происходит точно такой же порядок действий
}

/// <summary>
/// Функция для поиска значения в дереве
/// </summary>
/// <param name="node"> поддерево, в котором происходит поиск </param>
/// <param name="value"> искомое значение </param>
/// <returns> кол-во элементов с заданным значением в дереве </returns>
int FindValue(AVLTreeNode* node, int value) {
    if (!node) // если пришли в пустой узел (значение не найдено)
        return 0;

    if (value < node->value) // если искомое значение меньше чем значение текущего узла
        return FindValue(node->left, value); // идём налево 

    else if (value > node->value) // если искомое значение больше чем значение текущего узла
        return FindValue(node->right, value); // идём направо

    else // если значения равны, возвращаю, что элемент был найден
        return 1;
}

/// <summary>
/// Функция для удаления дерева из памяти
/// </summary>
/// <param name="node"> удаляемое поддерево </param>
void DeleteTree(AVLTreeNode* node) {
    if (node->left) // если существует левое поддерево
        DeleteTree(node->left); // удаляем сначала левое 

    if (node->right) // если существует правое поддерево
        DeleteTree(node->right); // удаляем сначала правое

    delete node; // только потом удаляем самого родителя
}
