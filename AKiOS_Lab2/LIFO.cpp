#include "includes.h"

// В ДАННОМ ФАЙЛЕ НАХОДЯТСЯ ВСЕ ФУНКЦИИ, ОТВЕЧАЮЩИЕ ЗА БИЗНЕС-ЛОГИКУ ДЛЯ ДИСЦИПЛИНЫ LIFO

/// <summary>
/// Метод для добавления элементов в список с дисциплиной LIFO
/// </summary>
/// <param name="tail"> "хвост" списка </param>
/// <param name="value"> добавляемое значение </param>
/// <returns> список с добавленным новым элементом (и новым хвостом соответственно) </returns>
LIFOElem* AddToLIFO(LIFOElem* tail, int value) {
    if (!tail) // если список изначально пуст, то просто возвращаю новый созданный элемент как список
        return new LIFOElem(value);

    //else
    LIFOElem* temp = new LIFOElem(value); // создаю экземпляр структуры LIFOElem с заданным значением value

    temp->next = tail; // т.к. новый элемент должен будет "покинуть" список первым, значит после него список "покинет" элемент, 
    //который должен был это сделать первым до добавления очередного элемента

    tail = temp; // выставляю указатель "хвоста" списка адрес в памяти, перейдя по которому можно найти только что созданный элемент

    return tail;
}

/// <summary>
/// Функция для полного создания списка с дисциплиной LIFO
/// </summary>
/// <returns> указатель на "хвост" списка (на последний введённый пользователем элемент) </returns>
LIFOElem* MakeLIFO() { 
    int value;
    LIFOElem* tail = nullptr;

    cout << "Введите значение - целое число (0 - конец ввода): > ";
    cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0 и оставить в этом случае список пустым

    while (value != 0) { // пока ненулевой ввод, добавляю элементы в список
        tail = AddToLIFO(tail, value);
        
        cout << "Введите значение - целое число (0 - конец ввода): > ";
        cin >> value;
    }

    return tail;
}

/// <summary>
/// Функция для вывода списка с дисциплиной LIFO, в нормальном порядке (с последнего введенного)
/// </summary>
/// <param name="tail"> "хвост" списка, который нужно вывести в консоль </param>
void LIFOPrintFromFirst(LIFOElem* tail) {

    if (tail == nullptr) { // если список пустой
        cout << "Список пуст!" << endl;
        return;
    }

    //else вывожу список с последнего введенного элемента до первого
    while (tail != nullptr) {
        cout << tail->value << " ";
        tail = tail->next;
    }
}

/// <summary>
/// Функция (итеративная!) для вывода списка с дисциплиной LIFO, в обратном порядке (с первого введенного)
/// </summary>
/// <param name="tail"> "хвост" списка, который нужно вывести в консоль </param>
void LIFOPrintFromLast(LIFOElem* tail) {

    if (tail == nullptr)  {// если список пустой
        cout << "Список пуст!" << endl;
        return;
    }

    LIFOElem* start = tail; // вспомогательный указатель, который будет идти по списку с начала, пока не дойдет до элемента, который только что был выведен в консоль
    LIFOElem* current = tail; // указатель на последний выведенный в консоль элемент

    while (current->next != nullptr) { // пока не дойду до последнего в списке элемента, "бегу вперед"
        current = current->next;
    }

    cout << current->value << " "; // вывожу последний элемент списка

    while (current != tail) { // пока не выведу первый элемент списка

        start = tail; // встаю на начало списка

        while (start->next != current) { // "бегу вперед" по списку, пока следующий элемент не окажется только что выведенным
            start = start->next;
        }

        current = start; // переставляю указатель, т.к. сейчас выведу значение именно этого узла

        cout << current->value << " "; // вывожу значение в консоль
    }
}

/// <summary>
/// Функция для удаления всех вхождений введенного значения из списка с дисциплиной LIFO
/// </summary>
/// <param name="tail"> последний введенный в список элемент </param>
/// <param name="EV"> значение, которое нужно удалить из списка </param>
void LIFORemove(LIFOElem*& tail, int EV) {
    LIFOElem* current = tail;
    LIFOElem* next;
    bool flag = false; // флаг, показывающий удалили что-то в итоге или нет

    //отдельно рассматриваю ситуацию с удалением элементов с первой позиции в списке, т.к. подходы к удалению из начала и из середины отличаются
    //смешивать их нельзя, т.к. это приведет к исключениям
    while (tail != nullptr && tail->value == EV) { // пока список не пустой и значение первого элемента равно тому, которое удаляем
        tail = current->next; // делаю "хвостом" следующий элемент в списке
        delete current; // удаляю элемент по указателю на прошлый "хвост"
        current = tail; // снова выставляю вспомогательный указатель на уже нынешний "хвост"
        flag = true; // элемент был удалён
    }

    // если к этому моменту список пуст, то current будет указывать на пустое место в памяти, у которого нет "next"
    if (current != nullptr)
        next = current->next;
    else
        next = nullptr;

    // пока не дойдем до конца списка (идём не с первого, а со второго элемента, так как первый был проверен в прошлом цикле и он точно не должен быть удалён)
    while (next != nullptr) {
        if (next->value == EV) { //если текущий элемент надо удалять
            current->next = next->next; // убираем ссылку на удаляемый элемент из предыдущего элемента, вместо этого туда встает следующий за удаляемым
            delete next; //удаляем элемент
            next = current->next; // переходим на след. элемент            
            flag = true; // элемент был удалён
        }
        else {
            current = next; // встаем вспомогательным указателем на элемент, который стоит перед тем, который сейчас будем проверять на удаление
            next = next->next; // переходим на след. элемент
        }       
    }
    
    if (flag)
        cout << "Элементы удалены!" << endl;
    else
        cout << "Нет элемента для удаления!" << endl;
}

/// <summary>
/// Метод для подсчёта количества элементов в списке
/// </summary>
/// <param name="tail"> хвост списка </param>
/// <param name="value"> искомое значение </param>
/// <returns> количество вхождений значения value в список </returns>
int LIFOCount(LIFOElem* tail, int value) {
    int count = 0;
    while (tail != nullptr) { // пока не дошли до конца списка
        if (tail->value == value)
            count++;

        tail = tail->next;
    }

    return count;
}