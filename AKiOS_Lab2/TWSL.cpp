#include "includes.h"

// В ДАННОМ ФАЙЛЕ НАХОДЯТСЯ ВСЕ ФУНКЦИИ, ОТВЕЧАЮЩИЕ ЗА БИЗНЕС-ЛОГИКУ ДВУНАПРАВЛЕННОГО СОРТИРОВАННОГО СПИСКА (ДИСЦИПЛИНА FIFO)

/// <summary>
/// Функция для создания двусвязного отсортированного списка
/// </summary>
/// <returns> кортеж с двумя указателями: голова и хвост списка </returns>
tuple<TWSLElem*, TWSLElem*> MakeTWSL() {
    int value;
    TWSLElem* head = nullptr;
    TWSLElem* tail = nullptr;
    TWSLElem* current = nullptr;

    cout << "Введите значение - целое число (0 - конец ввода): > ";
    cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0 и оставить в этом случае список пустым

    if (value != 0) {
        TWSLElem* temp = new TWSLElem(value);
        head = temp; // ставлю голову на первый элемент
        current = temp; // ставлю вспомогательный указатель на тот же первый элемент
        tail = temp; // ставлю хвост на первый элемент

        cout << "Введите значение - целое число (0 - конец ввода): > ";
        cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0 и оставить в этом случае список лишь с 1 элементом
    }

    while (value != 0)
    {
        TWSLElem* temp = new TWSLElem(value); // создаю новый экземпляр с заданным значением
        if (value < head->value) { // если элемент меньше самого первого в списке
            temp->next = head; // предыдущая голова встает на 2 место в списке (следует после только что введенного значения)
            head->prev = temp; // предыдущей голове даю ссылку на новую голову
            head = temp; // головой становится только что введенное значение
        }
        else { // больше или равно
            current = head; // вспомогательный указатель встает на голову списка, чтобы ее не потерять
            while (current->next != nullptr && current->next->value < value) { // пока следующий после current элемент меньше чем заданное значение
                current = current->next; // "бежим вперед" по списку
            }
            // сейчас мы стоим указателем current прямо перед местом, куда нужно вставить элемент

            temp->next = current->next; // передаем ссылку на следующий после current элемент нынешнему 
            temp->prev = current; // передаем новому элементу ссылку на его предыдущий
            current->next = temp; // предыдущему элементу перед текущим даем ссылку на текущий

            if (temp->next != nullptr) { // если вставили элемент не в конец
                temp->next->prev = temp;
            }
            else { // если вставили элемент в конец
                tail = temp;
            }
        }

        cout << "Введите значение - целое число (0 - конец ввода): > ";
        cin >> value;
    }

    return { head, tail };
}

/// <summary>
/// Функция для вывода списка с дисциплиной FIFO, в нормальном порядке (по возрастанию)
/// </summary>
/// <param name="head"> "голова" списка, который нужно вывести в консоль </param>
void TWSLPrintFromFirst(TWSLElem* head) {
    if (head == nullptr) { // если список пустой
        cout << "Список пуст!" << endl;
        return;
    }

    //else вывожу список по возрастанию
    while (head != nullptr) {
        cout << head->value << " ";
        head = head->next;
    }
}

/// <summary>
/// Функция (итеративная!) для вывода списка с дисциплиной FIFO, в обратном порядке (по убыванию)
/// </summary>
/// <param name="tail"> хвост списка </param>
void TWSLPrintFromLast(TWSLElem* tail) {
    if (tail == nullptr) { // если список пустой
        cout << "Список пуст!" << endl;
        return;
    }

    //else вывожу список по убыванию
    while (tail != nullptr) {
        cout << tail->value << " ";
        tail = tail->prev;
    }
}

/// <summary>
/// Функция для удаления всех вхождений введенного значения из списка с дисциплиной FIFO
/// </summary>
/// <param name="head"> первый в списке элемент </param>
/// <param name="EV"> значение, которое нужно удалить из списка </param>
void TWSLRemove(TWSLElem*& head, TWSLElem*& tail, int EV)
{
    TWSLElem* current = head;
    TWSLElem* next;
    bool flag = false; // флаг, показывающий удалили что-то в итоге или нет

    //отдельно рассматриваю ситуацию с удалением элементов с первой позиции в списке, т.к. подходы к удалению из начала и из середины отличаются
    //смешивать их нельзя, т.к. это приведет к исключениям
    while (head != nullptr && head->value == EV) { // пока список не пустой и значение первого элемента равно тому, которое удаляем
        head = current->next; // делаю "головой" следующий элемент в списке
        if (head != nullptr) // если в списке остались элементы
            head->prev = nullptr; // обнуляю указатель на предыдущий элемент списка
        delete current; // удаляю элемент по указателю на прошлую "голову"
        current = head; // снова выставляю вспомогательный указатель на уже нынешнюю "голову"
        flag = true;// элемент был удалён
    }

    // если к этому моменту список пуст, то current будет указывать на пустое место в памяти, у которого нет "next"
    if (current != nullptr)
        next = current->next;
    else
        next = nullptr;

    // пока не дойдем до конца списка (идём не с первого, а со второго элемента, так как первый был проверен в прошлом цикле и он точно не должен быть удалён)
    while (next != nullptr) {
        if (next->value == EV) { //если текущий элемент надо удалять
            current->next = next->next; // убираем ссылку на удаляемый элемент из предыдущего элемента, вместо этого туда встает следующий за удаляемым
            delete next; //удаляем элемент
            if (current->next != nullptr) { // если в списке остался не 1 элемент
                current->next->prev = current; // связываем следующимй и текущий элементы
            }
            next = current->next; // переходим на след. элемент
            flag = true; // элемент был удалён
        }
        else {
            current = next; // встаем вспомогательным указателем на элемент, который стоит перед тем, который сейчас будем проверять на удаление
            next = next->next; // переходим на след. элемент
        }
    }

    tail = current; // т.к. после прохождения всего цикла, current ТОЧНО стоит на последнем элементе, то можно перестраховаться и присвоить хвосту последний элемент

    if (flag)
        cout << "Элементы удалены!" << endl;
    else
        cout << "Нет элемента для удаления!" << endl;
}

/// <summary>
/// Метод для подсчёта количества элементов в списке
/// </summary>
/// <param name="head"> голова списка </param>
/// <param name="value"> искомое значение </param>
/// <returns> количество вхождений значения value в список </returns>
int TWSLCount(TWSLElem* head, int value) {
    int count = 0;
    while (head != nullptr) { // пока не дошли до конца списка
        if (head->value == value)
            count++;

        head = head->next;
    }

    return count;
}