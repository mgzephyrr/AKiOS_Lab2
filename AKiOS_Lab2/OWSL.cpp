#include "includes.h"

// В ДАННОМ ФАЙЛЕ НАХОДЯТСЯ ВСЕ ФУНКЦИИ, ОТВЕЧАЮЩИЕ ЗА БИЗНЕС-ЛОГИКУ ОДНОНАПРАВЛЕННОГО СОРТИРОВАННОГО СПИСКА (ДИСЦИПЛИНА FIFO)

/// <summary>
/// Функция для полного создания однонаправленного сортированного списка с дисциплиной FIFO
/// </summary>
/// <returns> указатель на "голову" списка (на первый введённый пользователем элемент) </returns>
OWSLElem* MakeOWSL() {
    int value;
    OWSLElem* head = nullptr;
    OWSLElem* current = nullptr;

    cout << "Введите значение - целое число (0 - конец ввода): > ";
    cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0 и оставить в этом случае список пустым

    if (value != 0) { // если ввели не ноль
        OWSLElem* temp = new OWSLElem(value);
        head = temp; // ставлю голову на первый элемент
        current = temp; // ставлю вспомогательный указатель на тот же первый элемент

        cout << "Введите значение - целое число (0 - конец ввода): > ";
        cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0 и оставить в этом случае список лишь с 1 элементом
    }

    while (value != 0)
    {
        OWSLElem* temp = new OWSLElem(value); // создаю новый экземпляр с заданным значением
        if (value < head->value) { // если элемент меньше самого первого в списке
            temp->next = head; // предыдущая голова встает на 2 место в списке (следует после только что введенного значения)
            head = temp; // головой становится только что введенное значение
        }
        else { // больше или равно
            current = head; // вспомогательный указатель встает на голову списка, чтобы ее не потерять
            while (current->next != nullptr && current->next->value < value) { // пока следующий после current элемент меньше чем заданное значение
                current = current->next; // "бежим вперед" по списку
            }
            // сейчас мы стоим указателем current прямо перед местом, куда нужно вставить элемент

            temp->next = current->next; // передаем ссылку на следующий после current элемент нынешнему 
            current->next = temp; // предыдущему элементу перед текущим даем ссылку на текущий
        }

        cout << "Введите значение - целое число (0 - конец ввода): > ";
        cin >> value;
    }

    return head;
}

/// <summary>
/// Функция для вывода списка с дисциплиной FIFO, в нормальном порядке (по возрастанию)
/// </summary>
/// <param name="head"> "голова" списка, который нужно вывести в консоль </param>
void OWSLPrintFromFirst(OWSLElem* head) {
    if (head == nullptr) { // если список пустой
        cout << "Список пуст!" << endl;
        return;
    }

    //else вывожу список по возрастанию
    while (head != nullptr) {
        cout << head->value << " ";
        head = head->next;
    }
}

/// <summary>
/// Функция (итеративная!) для вывода списка с дисциплиной FIFO, в обратном порядке (по убыванию)
/// </summary>
/// <param name="head"> "голова" списка, который нужно вывести в консоль </param>
void OWSLPrintFromLast(OWSLElem* head) {
    if (head == nullptr) { // если список пустой
        cout << "Список пуст!" << endl;
        return;
    }

    OWSLElem* start = head; // вспомогательный указатель, который будет идти по списку с начала, пока не дойдет до элемента, который только что был выведен в консоль
    OWSLElem* current; // указатель на последний выведенный в консоль элемент

    while (start->next != nullptr) { // пока не дойду до последнего в списке элемента, "бегу вперед"
        start = start->next;
    }

    current = start;
    cout << current->value << " "; // вывожу последний элемент списка

    while (current != head) { // пока не выведу первый элемент списка

        start = head; // встаю на начало списка

        while (start->next != current) { // "бегу вперед" по списку, пока следующий элемент не окажется только что выведенным
            start = start->next;
        }

        current = start; // переставляю указатель, т.к. сейчас выведу значение именно этого узла

        cout << current->value << " "; // вывожу значение в консоль
    }
}

/// <summary>
/// Функция для удаления всех вхождений введенного значения из списка с дисциплиной FIFO
/// </summary>
/// <param name="head"> первый в списке элемент </param>
/// <param name="EV"> значение, которое нужно удалить из списка </param>
void OWSLRemove(OWSLElem*& head, int EV)
{
    OWSLElem* current = head;
    OWSLElem* next;
    bool flag = false; // флаг, показывающий удалили что-то в итоге или нет

    //отдельно рассматриваю ситуацию с удалением элементов с первой позиции в списке, т.к. подходы к удалению из начала и из середины отличаются
    //смешивать их нельзя, т.к. это приведет к исключениям
    while (head != nullptr && head->value == EV) { // пока список не пустой и значение первого элемента равно тому, которое удаляем
        head = current->next; // делаю "головой" следующий элемент в списке
        delete current; // удаляю элемент по указателю на прошлую "голову"
        current = head; // снова выставляю вспомогательный указатель на уже нынешнюю "голову"
        flag = true; // элемент был удалён
    }

    // если к этому моменту список пуст, то current будет указывать на пустое место в памяти, у которого нет "next"
    if (current != nullptr)
        next = current->next;
    else
        next = nullptr;

    // пока не дойдем до конца списка (идём не с первого, а со второго элемента, так как первый был проверен в прошлом цикле и он точно не должен быть удалён)
    while (next != nullptr) {
        if (next->value == EV) { //если текущий элемент надо удалять
            current->next = next->next; // убираем ссылку на удаляемый элемент из предыдущего элемента, вместо этого туда встает следующий за удаляемым
            delete next; //удаляем элемент
            next = current->next; // переходим на след. элемент
            flag = true; // элемент был удалён
        }
        else {
            current = next; // встаем вспомогательным указателем на элемент, который стоит перед тем, который сейчас будем проверять на удаление
            next = next->next; // переходим на след. элемент
        }
    }

    if (flag)
        cout << "Элементы удалены!" << endl;
    else
        cout << "Нет элемента для удаления!" << endl;
}

/// <summary>
/// Метод для подсчёта количества элементов в списке
/// </summary>
/// <param name="head"> голова списка </param>
/// <param name="value"> искомое значение </param>
/// <returns> количество вхождений значения value в список </returns>
int OWSLCount(OWSLElem* head, int value) {
    int count = 0;
    while (head != nullptr) { // пока не дошли до конца списка
        if (head->value == value)
            count++;

        head = head->next;
    }

    return count;
}