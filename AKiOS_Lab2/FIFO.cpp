#include "includes.h"

// В ДАННОМ ФАЙЛЕ НАХОДЯТСЯ ВСЕ ФУНКЦИИ, ОТВЕЧАЮЩИЕ ЗА БИЗНЕС-ЛОГИКУ ДЛЯ ДИСЦИПЛИНЫ FIFO

/// <summary>
/// Функция для полного создания списка с дисциплиной FIFO
/// </summary>
/// <returns> указатель на "голову" списка (на первый введённый пользователем элемент) </returns>
FIFOElem* MakeFIFO() {
    int value;
    FIFOElem* head = nullptr;
    FIFOElem* current = nullptr;

    cout << "Введите значение - целое число (0 - конец ввода): > ";
    cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0 и оставить в этом случае список пустым

    if (value != 0) { // если ввели не ноль
        FIFOElem* temp = new FIFOElem(value);
        head = temp; // ставлю голову на первый элемент
        current = temp; // ставлю вспомогательный указатель на тот же первый элемент

        cout << "Введите значение - целое число (0 - конец ввода): > ";
        cin >> value; // прошу первый ввод вне цикла, чтобы учесть ситуацию, когда сразу ввели 0 и оставить в этом случае список лишь с 1 элементом
    }

    while (value != 0)
    {
        FIFOElem* temp = new FIFOElem(value); // создаю новый экземпляр с заданным значением
        current->next = temp; // даю ссылку на только что созданный элемент последнему на данный момент в списке 
        current = current->next; // встаю на последний элемент в списке

        cout << "Введите значение - целое число (0 - конец ввода): > ";
        cin >> value;
    }

    return head;
}

/// <summary>
/// Функция для вывода списка с дисциплиной FIFO, в нормальном порядке (с первого введенного)
/// </summary>
/// <param name="head"> "голова" списка, который нужно вывести в консоль </param>
void FIFOPrintFromFirst(FIFOElem* head) {
    if (head == nullptr) { // если список пустой
        cout << "Список пуст!" << endl;
        return;
    }

    //else вывожу список с первого введенного элемента до последнего
    while (head != nullptr) {
        cout << head->value << " ";
        head = head->next;
    }
}

/// <summary>
/// Функция (итеративная!) для вывода списка с дисциплиной FIFO, в обратном порядке (с последнего введенного)
/// </summary>
/// <param name="head"> "голова" списка, который нужно вывести в консоль </param>
void FIFOPrintFromLast(FIFOElem* head) {
    if (head == nullptr) { // если список пустой
        cout << "Список пуст!" << endl;
        return;
    }

    FIFOElem* start = head; // вспомогательный указатель, который будет идти по списку с начала, пока не дойдет до элемента, который только что был выведен в консоль
    FIFOElem* current = head; // указатель на последний выведенный в консоль элемент

    while (current->next != nullptr) { // пока не дойду до последнего в списке элемента, "бегу вперед"
        current = current->next;
    }

    cout << current->value << " "; // вывожу последний элемент списка

    while (current != head) { // пока не выведу первый элемент списка
        
        start = head; // встаю на начало списка

        while (start->next != current) { // "бегу вперед" по списку, пока следующий элемент не окажется только что выведенным
            start = start->next;
        }

        current = start; // переставляю указатель, т.к. сейчас выведу значение именно этого узла

        cout << current->value << " "; // вывожу значение в консоль
    }
}


/// <summary>
/// Функция для удаления всех вхождений введенного значения из списка с дисциплиной FIFO
/// </summary>
/// <param name="head"> первый введенный в список элемент </param>
/// <param name="EV"> значение, которое нужно удалить из списка </param>
void FIFORemove(FIFOElem*& head, int EV)
{
    FIFOElem* current = head;
    FIFOElem* next;
    bool flag = false; // флаг, показывающий удалили что-то в итоге или нет

    //отдельно рассматриваю ситуацию с удалением элементов с первой позиции в списке, т.к. подходы к удалению из начала и из середины отличаются
    //смешивать их нельзя, т.к. это приведет к исключениям
    while (head != nullptr && head->value == EV) { // пока список не пустой и значение первого элемента равно тому, которое удаляем
        head = current->next; // делаю "головой" следующий элемент в списке
        delete current; // удаляю элемент по указателю на прошлую "голову"
        current = head; // снова выставляю вспомогательный указатель на уже нынешнюю "голову"
        flag = true; // элемент был удалён
    }

    // если к этому моменту список пуст, то current будет указывать на пустое место в памяти, у которого нет "next"
    if (current != nullptr)
        next = current->next;
    else
        next = nullptr;

    // пока не дойдем до конца списка (идём не с первого, а со второго элемента, так как первый был проверен в прошлом цикле и он точно не должен быть удалён)
    while (next != nullptr) {
        if (next->value == EV) { //если текущий элемент надо удалять
            current->next = next->next; // убираем ссылку на удаляемый элемент из предыдущего элемента, вместо этого туда встает следующий за удаляемым
            delete next; //удаляем элемент
            next = current->next; // переходим на след. элемент
            flag = true; // элемент был удалён
        }
        else {
            current = next; // встаем вспомогательным указателем на элемент, который стоит перед тем, который сейчас будем проверять на удаление
            next = next->next; // переходим на след. элемент
        }
    }

    if (flag)
        cout << "Элементы удалены!" << endl;
    else
        cout << "Нет элемента для удаления!" << endl;
}

/// <summary>
/// Метод для подсчёта количества элементов в списке
/// </summary>
/// <param name="head"> голова списка </param>
/// <param name="value"> искомое значение </param>
/// <returns> количество вхождений значения value в список </returns>
int FIFOCount(FIFOElem* head, int value) {
    int count = 0;
    while (head != nullptr) { // пока не дошли до конца списка
        if (head->value == value)
            count++;

        head = head->next;
    }

    return count;
}